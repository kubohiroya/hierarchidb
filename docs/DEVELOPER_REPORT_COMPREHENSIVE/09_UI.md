# 第9部 UI (User Interface)

## Chapter 24: React UI アーキテクチャ (React UI Architecture) ⭐️⭐️⭐️⭐️

### 24.1 コンポーネント階層設計 (Component Hierarchy Design)

HierarchiDBのUI層は、React 18とMaterial-UIを基盤とした階層型コンポーネントアーキテクチャを採用しています。

```mermaid
graph TB
    subgraph "Application Layer"
        App["App Root"]
        Router["React Router v7"]
        ErrorBoundary["Global Error Boundary"]
    end
    
    subgraph "Layout Layer"
        MainLayout["Main Layout"]
        NavigationBar["Navigation Bar"]
        Sidebar["Collapsible Sidebar"]
        ContentArea["Content Area"]
    end
    
    subgraph "Feature Layer"
        TreeConsole["Tree Console"]
        AuthDialog["Authentication Dialog"]
        SettingsPanel["Settings Panel"]
        NotificationSystem["Notification System"]
    end
    
    subgraph "Component Layer"
        TreeTable["Tree Table"]
        NodeDialog["Node Dialog"]
        PluginPanel["Plugin Panel"]
        MemoryMonitor["Memory Monitor"]
    end
    
    subgraph "UI Primitives"
        Button["Custom Button"]
        Input["Custom Input"]
        Dialog["Custom Dialog"]
        DataGrid["Virtual Data Grid"]
    end
    
    App --> Router
    Router --> ErrorBoundary
    ErrorBoundary --> MainLayout
    
    MainLayout --> NavigationBar
    MainLayout --> Sidebar
    MainLayout --> ContentArea
    
    ContentArea --> TreeConsole
    ContentArea --> AuthDialog
    ContentArea --> SettingsPanel
    ContentArea --> NotificationSystem
    
    TreeConsole --> TreeTable
    TreeConsole --> NodeDialog
    TreeConsole --> PluginPanel
    TreeConsole --> MemoryMonitor
    
    TreeTable --> Button
    NodeDialog --> Input
    PluginPanel --> Dialog
    MemoryMonitor --> DataGrid
    
    classDef app fill:#e1f5fe
    classDef layout fill:#f3e5f5
    classDef feature fill:#fff3e0
    classDef component fill:#e8f5e9
    classDef primitive fill:#ffebee
    
    class App,Router,ErrorBoundary app
    class MainLayout,NavigationBar,Sidebar,ContentArea layout
    class TreeConsole,AuthDialog,SettingsPanel,NotificationSystem feature
    class TreeTable,NodeDialog,PluginPanel,MemoryMonitor component
    class Button,Input,Dialog,DataGrid primitive
```

### 24.2 状態管理パターン (State Management Patterns)

| 状態タイプ | 管理方法 | 永続化 | スコープ | パフォーマンス考慮 |
|------------|----------|--------|---------|--------------------|
| **グローバル状態** | React Context | localStorage | アプリ全体 | Context分割で最適化 |
| **ページ状態** | useState/useReducer | SessionStorage | ページ内 | useMemo/useCallback |
| **フォーム状態** | React Hook Form | なし | フォーム内 | Uncontrolled components |
| **ツリー状態** | カスタムHook | EphemeralDB | ツリービュー | 仮想化 + 遅延読み込み |
| **Worker通信状態** | SWR/React Query | なし | API呼び出し | Background refresh |

### 24.3 パフォーマンス最適化戦略 (Performance Optimization Strategy)

```mermaid
graph LR
    subgraph "レンダリング最適化"
        ReactMemo["React.memo"]
        useMemo["useMemo"]
        useCallback["useCallback"]
        VirtualScrolling["Virtual Scrolling"]
    end
    
    subgraph "バンドル最適化"
        CodeSplitting["Code Splitting"]
        LazyLoading["Lazy Loading"]
        TreeShaking["Tree Shaking"]
        BundleAnalysis["Bundle Analysis"]
    end
    
    subgraph "ネットワーク最適化"
        ResourceHints["Resource Hints"]
        ImageOptimization["Image Optimization"]
        CompressionOptimization["Compression"]
        CDNOptimization["CDN Optimization"]
    end
    
    subgraph "実行時最適化"
        DebounceThrottle["Debounce/Throttle"]
        IntersectionObserver["Intersection Observer"]
        WebWorkerOffload["Web Worker Offload"]
        ServiceWorker["Service Worker"]
    end
    
    ReactMemo --> CodeSplitting
    useMemo --> LazyLoading
    useCallback --> TreeShaking
    VirtualScrolling --> BundleAnalysis
    
    CodeSplitting --> ResourceHints
    LazyLoading --> ImageOptimization
    TreeShaking --> CompressionOptimization
    BundleAnalysis --> CDNOptimization
    
    ResourceHints --> DebounceThrottle
    ImageOptimization --> IntersectionObserver
    CompressionOptimization --> WebWorkerOffload
    CDNOptimization --> ServiceWorker
    
    classDef rendering fill:#e1f5fe
    classDef bundle fill:#f3e5f5
    classDef network fill:#fff3e0
    classDef runtime fill:#e8f5e9
    
    class ReactMemo,useMemo,useCallback,VirtualScrolling rendering
    class CodeSplitting,LazyLoading,TreeShaking,BundleAnalysis bundle
    class ResourceHints,ImageOptimization,CompressionOptimization,CDNOptimization network
    class DebounceThrottle,IntersectionObserver,WebWorkerOffload,ServiceWorker runtime
```

## Chapter 25: Tree Console UI (Tree Console UI) ⭐️⭐️⭐️⭐️⭐️

### 25.1 TreeConsole アーキテクチャ (TreeConsole Architecture)

```mermaid
graph TB
    subgraph "TreeConsole Main"
        TreeConsoleBase["TreeConsole Base Container"]
        TreeState["Tree State Management"]
        SelectionManager["Selection Manager"]
    end
    
    subgraph "Header Components"
        Breadcrumb["Breadcrumb Navigation"]
        Toolbar["Action Toolbar"]
        SearchBar["Search/Filter Bar"]
    end
    
    subgraph "Main Components"
        TreeTable["Virtual Tree Table"]
        NodeEditor["Node Editor Panel"]
        PluginArea["Plugin Integration Area"]
    end
    
    subgraph "Footer Components"
        StatusBar["Status Bar"]
        ProgressIndicator["Progress Indicator"]
        MemoryUsage["Memory Usage Display"]
    end
    
    subgraph "Interaction Components"
        ContextMenu["Context Menu"]
        DragDropHandler["Drag & Drop Handler"]
        KeyboardHandler["Keyboard Shortcuts"]
    end
    
    TreeConsoleBase --> TreeState
    TreeState --> SelectionManager
    
    TreeConsoleBase --> Breadcrumb
    TreeConsoleBase --> Toolbar
    TreeConsoleBase --> SearchBar
    
    TreeState --> TreeTable
    SelectionManager --> NodeEditor
    TreeConsoleBase --> PluginArea
    
    TreeConsoleBase --> StatusBar
    TreeConsoleBase --> ProgressIndicator
    TreeConsoleBase --> MemoryUsage
    
    TreeTable --> ContextMenu
    TreeTable --> DragDropHandler
    TreeConsoleBase --> KeyboardHandler
    
    classDef main fill:#e1f5fe
    classDef header fill:#f3e5f5
    classDef maincontent fill:#fff3e0
    classDef footer fill:#e8f5e9
    classDef interaction fill:#ffebee
    
    class TreeConsoleBase,TreeState,SelectionManager main
    class Breadcrumb,Toolbar,SearchBar header
    class TreeTable,NodeEditor,PluginArea maincontent
    class StatusBar,ProgressIndicator,MemoryUsage footer
    class ContextMenu,DragDropHandler,KeyboardHandler interaction
```

### 25.2 仮想化Tree Table実装 (Virtualized Tree Table Implementation)

```typescript
// 仮想化TreeTableの実装例
interface VirtualTreeTableProps {
  rootNodeId: NodeId;
  height: number;
  itemHeight: number;
  overscan?: number;
  onNodeSelect?: (nodeId: NodeId) => void;
  onNodeExpand?: (nodeId: NodeId, expanded: boolean) => void;
}

const VirtualTreeTable: React.FC<VirtualTreeTableProps> = ({
  rootNodeId,
  height,
  itemHeight,
  overscan = 10,
  onNodeSelect,
  onNodeExpand,
}) => {
  // フラット化されたツリーノードリスト
  const flattenedNodes = useMemo(() => {
    return flattenTreeNodes(rootNodeId, expandedNodes);
  }, [rootNodeId, expandedNodes]);

  // 仮想化の設定
  const rowVirtualizer = useVirtualizer({
    count: flattenedNodes.length,
    getScrollElement: () => scrollElementRef.current,
    estimateSize: () => itemHeight,
    overscan,
  });

  // 選択状態の管理
  const [selectedNodes, setSelectedNodes] = useState<Set<NodeId>>(new Set());
  const [expandedNodes, setExpandedNodes] = useState<Set<NodeId>>(new Set());

  // ノード展開/折りたたみ
  const handleNodeExpand = useCallback((nodeId: NodeId, expanded: boolean) => {
    setExpandedNodes(prev => {
      const newSet = new Set(prev);
      if (expanded) {
        newSet.add(nodeId);
      } else {
        newSet.delete(nodeId);
      }
      return newSet;
    });
    
    onNodeExpand?.(nodeId, expanded);
  }, [onNodeExpand]);

  // キーボード操作
  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    const selectedArray = Array.from(selectedNodes);
    const currentIndex = flattenedNodes.findIndex(node => 
      selectedArray.includes(node.id)
    );

    switch (event.key) {
      case 'ArrowDown':
        if (currentIndex < flattenedNodes.length - 1) {
          const nextNode = flattenedNodes[currentIndex + 1];
          setSelectedNodes(new Set([nextNode.id]));
          onNodeSelect?.(nextNode.id);
        }
        break;
        
      case 'ArrowUp':
        if (currentIndex > 0) {
          const prevNode = flattenedNodes[currentIndex - 1];
          setSelectedNodes(new Set([prevNode.id]));
          onNodeSelect?.(prevNode.id);
        }
        break;
        
      case 'ArrowRight':
        if (currentIndex >= 0) {
          const currentNode = flattenedNodes[currentIndex];
          if (!expandedNodes.has(currentNode.id) && currentNode.hasChildren) {
            handleNodeExpand(currentNode.id, true);
          }
        }
        break;
        
      case 'ArrowLeft':
        if (currentIndex >= 0) {
          const currentNode = flattenedNodes[currentIndex];
          if (expandedNodes.has(currentNode.id)) {
            handleNodeExpand(currentNode.id, false);
          }
        }
        break;
    }
  }, [selectedNodes, expandedNodes, flattenedNodes, onNodeSelect, handleNodeExpand]);

  return (
    <div
      ref={scrollElementRef}
      style={{ height, overflow: 'auto' }}
      onKeyDown={handleKeyDown}
      tabIndex={0}
    >
      <div
        style={{
          height: `${rowVirtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative',
        }}
      >
        {rowVirtualizer.getVirtualItems().map((virtualItem) => {
          const node = flattenedNodes[virtualItem.index];
          const isSelected = selectedNodes.has(node.id);
          const isExpanded = expandedNodes.has(node.id);

          return (
            <TreeNodeRow
              key={node.id}
              node={node}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: `${virtualItem.size}px`,
                transform: `translateY(${virtualItem.start}px)`,
              }}
              isSelected={isSelected}
              isExpanded={isExpanded}
              onSelect={() => {
                setSelectedNodes(new Set([node.id]));
                onNodeSelect?.(node.id);
              }}
              onExpand={(expanded) => handleNodeExpand(node.id, expanded)}
            />
          );
        })}
      </div>
    </div>
  );
};
```

### 25.3 ドラッグ＆ドロップシステム (Drag & Drop System)

| 操作タイプ | 許可される移動 | 制約 | フィードバック |
|------------|----------------|------|----------------|
| **ノード移動** | 同一ツリー内 | 親子循環禁止 | ドロップゾーン強調 |
| **ファイルアップロード** | 外部→ツリー | ファイル形式制限 | プログレスバー |
| **テキストドロップ** | 外部→ノード | テキスト形式のみ | 挿入位置表示 |
| **複数選択移動** | バッチ操作 | 一貫性チェック | まとめて移動表示 |

```mermaid
graph LR
    subgraph "Drag Events"
        DragStart["dragstart"]
        Drag["drag"]
        DragEnd["dragend"]
    end
    
    subgraph "Drop Events"
        DragEnter["dragenter"]
        DragOver["dragover"]
        DragLeave["dragleave"]
        Drop["drop"]
    end
    
    subgraph "Visual Feedback"
        GhostImage["Ghost Image"]
        DropZone["Drop Zone Highlight"]
        InsertionIndicator["Insertion Indicator"]
    end
    
    subgraph "Validation"
        PermissionCheck["Permission Check"]
        ConstraintValidation["Constraint Validation"]
        ConflictResolution["Conflict Resolution"]
    end
    
    DragStart --> DragEnter
    Drag --> DragOver
    DragEnd --> Drop
    
    DragEnter --> GhostImage
    DragOver --> DropZone
    DragLeave --> InsertionIndicator
    
    Drop --> PermissionCheck
    PermissionCheck --> ConstraintValidation
    ConstraintValidation --> ConflictResolution
    
    classDef drag fill:#e1f5fe
    classDef drop fill:#f3e5f5
    classDef visual fill:#fff3e0
    classDef validation fill:#e8f5e9
    
    class DragStart,Drag,DragEnd drag
    class DragEnter,DragOver,DragLeave,Drop drop
    class GhostImage,DropZone,InsertionIndicator visual
    class PermissionCheck,ConstraintValidation,ConflictResolution validation
```

## Chapter 26: プラグイン UI統合 (Plugin UI Integration) ⭐️⭐️⭐️⭐️

### 26.1 プラグインUI アーキテクチャ (Plugin UI Architecture)

```mermaid
graph TB
    subgraph "Plugin UI Framework"
        PluginRegistry["UI Plugin Registry"]
        ComponentFactory["Component Factory"]
        ThemeProvider["Theme Provider"]
    end
    
    subgraph "Dynamic Components"
        DialogComponents["Dialog Components"]
        PanelComponents["Panel Components"]
        IconComponents["Icon Components"]
        ToolbarComponents["Toolbar Components"]
    end
    
    subgraph "Integration Points"
        NodeDialog["Node Dialog Integration"]
        ContextMenu["Context Menu Integration"]
        Toolbar["Toolbar Integration"]
        StatusBar["Status Bar Integration"]
    end
    
    subgraph "Communication"
        PluginEvents["Plugin Event Bus"]
        StateShare["Shared State"]
        APIClient["Plugin API Client"]
    end
    
    PluginRegistry --> ComponentFactory
    ComponentFactory --> ThemeProvider
    
    ComponentFactory --> DialogComponents
    ComponentFactory --> PanelComponents
    ComponentFactory --> IconComponents
    ComponentFactory --> ToolbarComponents
    
    DialogComponents --> NodeDialog
    PanelComponents --> ContextMenu
    IconComponents --> Toolbar
    ToolbarComponents --> StatusBar
    
    NodeDialog --> PluginEvents
    ContextMenu --> StateShare
    Toolbar --> APIClient
    
    classDef framework fill:#e1f5fe
    classDef components fill:#f3e5f5
    classDef integration fill:#fff3e0
    classDef communication fill:#e8f5e9
    
    class PluginRegistry,ComponentFactory,ThemeProvider framework
    class DialogComponents,PanelComponents,IconComponents,ToolbarComponents components
    class NodeDialog,ContextMenu,Toolbar,StatusBar integration
    class PluginEvents,StateShare,APIClient communication
```

### 26.2 動的コンポーネント読み込み (Dynamic Component Loading)

```typescript
// 動的プラグインコンポーネント読み込みシステム
class PluginComponentRegistry {
  private componentCache = new Map<string, React.ComponentType<any>>();
  private loadingPromises = new Map<string, Promise<React.ComponentType<any>>>();

  async loadComponent(
    pluginId: string, 
    componentType: 'dialog' | 'panel' | 'icon'
  ): Promise<React.ComponentType<any>> {
    const cacheKey = `${pluginId}:${componentType}`;
    
    // キャッシュから取得
    if (this.componentCache.has(cacheKey)) {
      return this.componentCache.get(cacheKey)!;
    }
    
    // 読み込み中の場合は同じPromiseを返す
    if (this.loadingPromises.has(cacheKey)) {
      return this.loadingPromises.get(cacheKey)!;
    }
    
    // 動的インポート実行
    const loadingPromise = this.performDynamicImport(pluginId, componentType);
    this.loadingPromises.set(cacheKey, loadingPromise);
    
    try {
      const component = await loadingPromise;
      this.componentCache.set(cacheKey, component);
      return component;
    } finally {
      this.loadingPromises.delete(cacheKey);
    }
  }

  private async performDynamicImport(
    pluginId: string, 
    componentType: string
  ): Promise<React.ComponentType<any>> {
    try {
      // プラグインモジュールの動的インポート
      const module = await import(`@hierarchidb/plugin-${pluginId}`);
      
      // コンポーネントタイプに応じた取得
      switch (componentType) {
        case 'dialog':
          return module.DialogComponent;
        case 'panel':
          return module.PanelComponent;
        case 'icon':
          return module.IconComponent;
        default:
          throw new Error(`Unknown component type: ${componentType}`);
      }
      
    } catch (error) {
      console.error(`Failed to load plugin component: ${pluginId}:${componentType}`, error);
      
      // フォールバック用デフォルトコンポーネント
      return this.getDefaultComponent(componentType);
    }
  }

  private getDefaultComponent(componentType: string): React.ComponentType<any> {
    switch (componentType) {
      case 'dialog':
        return ({ children }: { children: React.ReactNode }) => (
          <div>Plugin dialog not available: {children}</div>
        );
      case 'panel':
        return ({ children }: { children: React.ReactNode }) => (
          <div>Plugin panel not available: {children}</div>
        );
      case 'icon':
        return () => <span>?</span>;
      default:
        return () => <div>Unknown component</div>;
    }
  }
}

// React Suspense と組み合わせた使用例
const DynamicPluginComponent: React.FC<{
  pluginId: string;
  componentType: 'dialog' | 'panel' | 'icon';
  props: any;
}> = ({ pluginId, componentType, props }) => {
  const [Component, setComponent] = useState<React.ComponentType<any> | null>(null);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let cancelled = false;
    
    PluginComponentRegistry.getInstance()
      .loadComponent(pluginId, componentType)
      .then(component => {
        if (!cancelled) {
          setComponent(() => component);
        }
      })
      .catch(error => {
        if (!cancelled) {
          setError(error);
        }
      });
      
    return () => {
      cancelled = true;
    };
  }, [pluginId, componentType]);

  if (error) {
    return <div>Error loading plugin component: {error.message}</div>;
  }

  if (!Component) {
    return <div>Loading plugin component...</div>;
  }

  return <Component {...props} />;
};
```

### 26.3 テーマとスタイリング統合 (Theme and Styling Integration)

| スタイリング要素 | 実装方法 | カスタマイズ性 | パフォーマンス |
|------------------|----------|----------------|----------------|
| **グローバルテーマ** | MUI Theme Provider | 高 | 優秀 |
| **コンポーネントスタイル** | styled-components | 高 | 良好 |
| **プラグイン固有スタイル** | CSS Modules | 中 | 優秀 |
| **動的スタイル** | CSS-in-JS | 高 | 中程度 |
| **レスポンシブデザイン** | MUI Breakpoints | 高 | 優秀 |

```mermaid
graph LR
    subgraph "Theme System"
        BaseTheme["Base Theme"]
        LightTheme["Light Theme"]
        DarkTheme["Dark Theme"]
        HighContrastTheme["High Contrast Theme"]
    end
    
    subgraph "Component Styling"
        GlobalStyles["Global Styles"]
        ComponentStyles["Component Styles"]
        PluginStyles["Plugin Styles"]
        CustomStyles["Custom Styles"]
    end
    
    subgraph "Runtime Styling"
        ThemeSwitch["Theme Switching"]
        DynamicColors["Dynamic Colors"]
        ResponsiveLayout["Responsive Layout"]
        AnimationSystem["Animation System"]
    end
    
    subgraph "Performance"
        StyleOptimization["Style Optimization"]
        CSSExtraction["CSS Extraction"]
        Minification["Minification"]
        LazyLoading["Lazy Loading"]
    end
    
    BaseTheme --> GlobalStyles
    LightTheme --> ComponentStyles
    DarkTheme --> PluginStyles
    HighContrastTheme --> CustomStyles
    
    GlobalStyles --> ThemeSwitch
    ComponentStyles --> DynamicColors
    PluginStyles --> ResponsiveLayout
    CustomStyles --> AnimationSystem
    
    ThemeSwitch --> StyleOptimization
    DynamicColors --> CSSExtraction
    ResponsiveLayout --> Minification
    AnimationSystem --> LazyLoading
    
    classDef theme fill:#e1f5fe
    classDef component fill:#f3e5f5
    classDef runtime fill:#fff3e0
    classDef performance fill:#e8f5e9
    
    class BaseTheme,LightTheme,DarkTheme,HighContrastTheme theme
    class GlobalStyles,ComponentStyles,PluginStyles,CustomStyles component
    class ThemeSwitch,DynamicColors,ResponsiveLayout,AnimationSystem runtime
    class StyleOptimization,CSSExtraction,Minification,LazyLoading performance
```

## まとめ (Summary)

UI層では、現代的で高性能なReactアプリケーションを構築しました：

- **コンポーネント階層**: 再利用可能で保守性の高い階層設計
- **TreeConsole**: 仮想化による大規模データ表示対応
- **プラグイン統合**: 動的コンポーネント読み込みによる拡張性

この設計により、ユーザーフレンドリーで高性能なインターフェースを提供し、プラグインによる機能拡張も容易に実現できます。