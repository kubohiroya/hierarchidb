# 高度なツリー操作実装 - 要件定義書

## 1. 概要

Task 12では、eria-cartographから移植される高度なツリー操作機能を実装します。
効率的なツリー複製、子孫グループ化、再帰処理などの複雑なアルゴリズムを含みます。

## 2. 機能要件

### 2.1 ブランチ複製機能 (duplicateBranch)

**目的**: 指定されたノード以下の部分木全体を新しい親に複製する

**入力パラメータ**:
- `sourceId: TreeNodeId` - 複製元のルートノード
- `newParentId: TreeNodeId` - 複製先の親ノード  
- `idMapping: Map<TreeNodeId, TreeNodeId>` - 旧IDと新IDのマッピング（出力用）
- `branchRootMode: boolean = true` - ルートノード名に"(Copy)"を付与するか

**出力仕様**:
- `Promise<void>` - 複製完了の非同期処理
- `idMapping` に全ての旧ID→新IDマッピングが格納される

**処理仕様**:
1. BFS（幅優先探索）でノード階層を順次処理
2. 各ノードに新しいUUIDを生成・マッピング
3. 子ノードを処理キューに追加して階層構造を維持
4. データベースへの一括登録でパフォーマンス最適化

### 2.2 子孫グループ化機能 (groupDescendants)

**目的**: ノードIDリストから親子関係のないトップレベルノードのみを抽出

**入力パラメータ**:
- `ids: TreeNodeId[]` - 対象ノードIDの配列

**出力仕様**:
- `Promise<TreeNode[]>` - トップレベルノードの配列

**処理仕様**:
1. 各ノードについて、その祖先がIDセットに含まれるかチェック
2. 祖先がセットに含まれない場合、そのノードをトップレベルと判定
3. 循環参照を検出し、無限ループを防止
4. 効率的な祖先トラバーサルアルゴリズム

### 2.3 全子孫取得機能 (getAllDescendants)

**目的**: 指定ノード以下の全ての子孫ノードIDを効率的に取得

**入力パラメータ**:
- `nodeId: TreeNodeId` - ルートノードID

**出力仕様**:
- `Promise<TreeNodeId[]>` - 全子孫ノードIDの配列

**処理仕様**:
1. BFSアルゴリズムによる階層順序での取得
2. バッチ処理（100ノードずつ）でパフォーマンス最適化
3. 循環参照検出機能
4. メモリ効率を考慮したストリーミング処理

## 3. 非機能要件

### 3.1 パフォーマンス要件

- **大規模データ対応**: 10,000ノードの部分木複製が30秒以内
- **バッチサイズ**: 100ノードずつの効率的な処理
- **メモリ効率**: ストリーミング処理でメモリ使用量を最小化
- **データベース効率**: bulkAdd/bulkUpdate による一括処理

### 3.2 信頼性要件

- **循環参照検出**: 無限ループの防止機能
- **トランザクション整合性**: 部分的失敗時のロールバック
- **エラーハンドリング**: 詳細なエラー情報の提供
- **データ整合性**: ID重複やオーファンノードの防止

### 3.3 保守性要件

- **モジュラー設計**: 各機能の独立性と再利用性
- **テスト容易性**: モック可能な設計
- **ログ出力**: デバッグ情報の適切な出力
- **型安全性**: TypeScriptの厳密な型チェック

## 4. 基本使用例

### 4.1 ブランチ複製の使用例

```typescript
// 基本的な複製
const idMapping = new Map<TreeNodeId, TreeNodeId>();
await duplicateBranch(db, 'source-node-1', 'new-parent', idMapping);

// コピー名なしモード（内部ノード複製）
await duplicateBranch(db, 'source-node-1', 'new-parent', idMapping, false);

// マッピング結果の確認
console.log('旧ID:', Array.from(idMapping.keys()));
console.log('新ID:', Array.from(idMapping.values()));
```

### 4.2 子孫グループ化の使用例

```typescript
// 複数選択されたノードからトップレベルを抽出
const selectedIds = ['node-1', 'node-2', 'node-1-child', 'node-3'];
const topLevelNodes = await groupDescendants(db, selectedIds);

// node-1-child は node-1 の子なので除外される
// 結果: [node-1, node-2, node-3] のみ
```

### 4.3 全子孫取得の使用例

```typescript
// フォルダ配下の全ファイル取得
const allDescendants = await getAllDescendants(db, 'folder-root');

// 削除前の影響範囲確認
console.log(`${allDescendants.length}個のノードが影響を受けます`);
```

## 5. エラーケース

### 5.1 複製時のエラー

- **存在しないソースノード**: `NODE_NOT_FOUND` エラー
- **不正な親ノード**: `PARENT_NOT_FOUND` エラー  
- **循環参照の発生**: `CIRCULAR_REFERENCE` エラー
- **データベース容量不足**: `DATABASE_ERROR` エラー

### 5.2 グループ化時のエラー

- **空の入力配列**: 空配列を正常に返却
- **存在しないノード**: 該当ノードを無視して継続処理
- **循環参照データ**: 検出して安全に処理

### 5.3 子孫取得時のエラー

- **存在しないルートノード**: 空配列を返却
- **権限不足**: `PERMISSION_DENIED` エラー
- **深すぎる階層**: 最大深度制限でタイムアウト防止

## 6. テスト要件

### 6.1 正常系テスト

- **単一ノード複製**: リーフノードの複製
- **小規模ブランチ複製**: 3階層程度の部分木複製  
- **大規模ブランチ複製**: 1000ノード以上の複製
- **グループ化基本**: 親子関係のあるノード群の処理
- **全子孫取得**: 各階層での正確な取得

### 6.2 異常系テスト

- **存在しないノード指定**: 適切なエラーハンドリング
- **循環参照データ**: 検出と安全な処理
- **データベースエラー**: 適切なロールバック
- **メモリ不足状況**: リソース制限時の動作

### 6.3 エッジケーステスト

- **空の入力**: 空配列・undefined値の処理
- **ルートノード**: 最上位ノードの特別処理
- **大量データ**: 10000ノード規模でのパフォーマンス
- **同時実行**: 並行処理時の整合性

### 6.4 パフォーマンステスト

- **レスポンス時間**: 各機能の実行時間測定
- **メモリ使用量**: 大規模データ処理時のメモリ効率
- **データベース負荷**: クエリ最適化の効果測定
- **スケーラビリティ**: データ量増加時の性能特性

## 7. 実装制約

### 7.1 技術制約

- **データベース**: Dexie (IndexedDB) を使用
- **TypeScript**: 厳密な型安全性を維持
- **非同期処理**: async/await パターンを統一使用
- **エラー処理**: 独自エラークラスによる詳細情報提供

### 7.2 ビジネス制約

- **ユーザー体験**: 長時間処理時の進捗表示サポート
- **データ整合性**: 部分的失敗時の一貫性保持
- **リソース効率**: 他機能への影響最小化
- **拡張性**: 将来の機能追加に対応可能な設計

## 8. 成功基準

### 8.1 機能的成功基準

- [ ] 全ての基本使用例が正常動作
- [ ] エラーケースが適切に処理される
- [ ] 大規模データで性能要件を満足
- [ ] 循環参照が確実に検出・防止される

### 8.2 技術的成功基準

- [ ] テストカバレッジ90%以上
- [ ] 型安全性エラーゼロ
- [ ] メモリリークの発生なし
- [ ] ドキュメント整備完了

### 8.3 品質基準

- [ ] コードレビュー合格
- [ ] パフォーマンステスト合格
- [ ] セキュリティ検査合格  
- [ ] 保守性評価合格